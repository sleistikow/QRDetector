\documentclass[a4paper, oneside, 12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc} 
\usepackage[ngerman]{babel}

\usepackage{parskip}
\usepackage{setspace}
\onehalfspacing

\usepackage[bookmarks, pageanchor, hidelinks]{hyperref}
\usepackage[left=2.5cm, right=4cm, top=2.0cm, bottom=2.0cm]{geometry}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}

\DeclareMathSymbol{*}{\mathbin}{symbols}{"01} % Ersetzt alle * durch \cdot in Math mode

\title{Detektion von planar aufgenommenen QR-Codes}
\author{Christian Dielitz, Simon Leistikow, Frederik Probst}

\begin{document}

\thispagestyle{empty}  % Entfernt die Seitenzahl der Titelseite
\newgeometry{top=3cm,bottom=2cm,right=3cm,left=3cm}

\hspace*{1em}
\begin{center}
	\includegraphics[width=10cm]{images/wwu_logo}
	\par
	\vspace*{8ex}
	\Huge
	\Large\textsc{QR-Code Detektion}
	
	\vspace{10pt}
	\large Detektion von planar aufgenommenen QR-Codes
	
	\par
	\normalsize
	\vspace*{8ex}
	\normalsize
	Dokumentation zum Abschluss des\\
	\large
	\textsc{Computer Vision Praktikum}
	%			\textsc{Master of Science}
	\par
	\normalsize
	\vspace*{12ex}
	Westfälische Wilhelms-Universität Münster\\
	Fachbereich Mathematik und Informatik\\
\end{center}
\par

\vspace*{34ex}
Eingereicht von:\\
\large
\textit{Christian Dielitz, Simon Leistikow, Frederik Probst}
\par
\normalsize
\vspace*{4ex}
Münster, 24.03.2017
\vfill
\hspace*{1em}

\newgeometry{left=2.5cm, right=4cm, top=2.0cm, bottom=2.0cm}


	
%\maketitle
\newpage

\tableofcontents
\newpage

\section{Einleitung}
\label{s:einleitung}
In der heutigen, digitalen Welt wird der einfache und schnelle Austausch von Informationen immer wichtiger. Als eines von vielen Kommunikationsträger dient dabei der sogenannte Quick Response (kurz QR) Code, da er Informationen gut komprimieren und durch bestimmte Software schnell wieder zurück verarbeitet werden kann.

Ein QR-Code ist im wesentlichen ein Raster von schwarzen und weißen Flächen, welche Quadratisch angeordnet sind. In aktuelleren Standards ist es allerdings auch erlaubt, kleinere Bilder (wie z.B. Firmenlogos) in den QR-Code zu integrieren. Heutzutage sind QR-Codes sehr populär und werden meist zur Kodierung von Internetseiten verwendet. Der Einsatzbereich eines QR-Codes beschränkt sich allerdings nicht nur auf URL Komprimierung: Mit seiner Hilfe lässt sich jeder beliebige Text, Bilder oder sogar Hologramme kompakt darstellen. Ein wesentliches Problem von QR-Codes ist allerdings, dass nicht direkt ersichtlich ist, welche Daten ein QR-Code enthält. Beispielsweise wäre es möglich Schadsoftware zu kodieren, welche beim Lesen ausgeführt wird und das entsprechende Lesegerät befällt.

Da die Eingabe eines QR-Codes meist durch ein aufgenommenes Bild einer Kamera vorliegt, ist es unumgänglich, dass eine schnelle Lokalisierung und Transformation in einen lesbaren Zustand des QR Codes durchgeführt werden muss.

Innerhalb diese Praktikums haben wir uns damit auseinander gesetzt, wie man planar aufgenommene QR-Codes möglichst schnell und zuverlässig aus einem Bild extrahieren kann. Dazu haben wir, basierend auf OpenCV, ein Programm entwickelt, welches sowohl Bilder von der Webcam eines Computers aufnehmen als auch schon gespeicherte Bilder laden kann und den  darin enthaltenen QR Code als eigenständiges Bild extrahiert.

\subsection{Aufgabenstellung}
\label{ss:aufgabe}

\newpage

\section{Grundlagen}
\label{s:grundlagen}

\subsection{Aufbau eines QR-Codes}
\label{ss:aufbau}

Ein QR-Code in eine Matrix $M = n \times n$ \Big(auf Grund der aktuellen Standards gilt $n \in \big\{17+4*v \,\, | \,\, v \in  \{1,\dots, 40\}\big\}$\Big) welche die kodierten Daten in Binär Form darstellt. Ein schwarzes Quadrat stellt dabei eine 1 dar und ein leeres, weißes Feld eine 0.

\begin{figure}[h]
	\includegraphics[width=\textwidth]{images/aufbau.png}
	\caption{Aufbau eines Beispiel QR-Codes}
	\label{fig:aufbau}
\end{figure}

Die in Abbildung \ref{fig:aufbau} grün markierten Quadrate sind die Positionsmarker des QR-Codes. Durch sie ist die Ausrichtung und Position eindeutig festgelegt. Außerdem ist es mit Ihrer Hilfe möglich, den vierten Eckpunkt zu bestimmen. Sie sind genau 8 Module Groß und der äußere, weiße Rand, sowie der Abstand vom inneren zum äußeren Quadrat ist genau 1 Bit breit.

Am äußeren Rand der Positionsmarker verläuft das sogenannte Timing-Pattern, welches abwechselnd aus schwarzen und weißen Modulen besteht. Es dient einzig zur vereinfachten Bestimmung der Positionsmarker und kann für eine spätere Transformation hilfreich sein.

Direkt an die Positionsmarker oben rechts und unten links grenzen die Versionsinformationen an,  welche durch die roten Flächen gekennzeichnet sind. Sie beschreiben die verwendete Version des QR Codes, welche wiederum die Größe des QR-Code festlegt. In der zuletzt erschienenen Version 40 ist, durch die oben beschriebene Formel, eine maximale Größe von $177 \times 177$ Datenpunkten erlaubt.

An der jeweils anderen Seite der beiden Positionsmarker und zusätzlich an beiden Seiten vom Positionsmarker oben links ist das jeweilige Format des QR-Codes dargestellt (blaue Streifen in Abbildung \ref{fig:aufbau}). Die Streifen sind jeweils genau ein Bit Breit ist und enthalten die Informationen über das Fehlerkorrektur-Level und das verwendete Masken-Pattern um den QR Code zu kodieren. Diese Eigenschaften werden in Kapitel \ref{ss:fehlerkorrektur} und \ref{ss:codierung} noch genauer  betrachtet.

Jeder QR-Code ist von einer sogenannten Sperrzone umgeben, welche komplett weiß sein muss. Diese weißen Pixel enthalten noch keine Informationen über die kodierten Daten und dienen zur Freilegung der Positionsmarker, was für die Konturerkennung notwendig ist. Die Sperrzone umfasst den gesamten QR-Code und ist an jeder Stelle gleich Breit.

Ab Version 2 wurden außerdem zusätzliche Ausrichtungsmarker eingeführt, welche die Berechnung der Position noch einmal vereinfachen sollen. Sie sind deutlich kleiner (jeweils 5 Module in Länge und Breite) als die eigentlichen Positionsmarker und können dem QR-Code optional hinzugefügt werden.

Beachtet man all diese Formalien, so ist es mit folgender Formel möglich, den Speicherplatz eines QR-Codes zu berechnen:
\begin{align*}
&size &&= (17 + 4 * v)^2 \hspace{200pt} | \,\, v \in 1,\dots,40\\
&info &&= Position + Ausrichtung + TimingPattern + Format + Version\\
&bits &&= size - info
\end{align*}

Im Falle der aktuellsten Version 40 mit einem Fehlerkorrekturlevel L (7\%) ist also eine Kodierung von $23648$ Bits möglich.

\subsection{Fehlerkorrektur}
\label{ss:fehlerkorrektur}

\subsection{Codierung der Daten}
\label{ss:codierung}




\newpage

\section{Implementierung}
\label{s:implementierung}

Die wesentliche Aufgabe des Praktikums war es, die recherchierten Grundlagen (siehe Kapitel \ref{s:grundlagen}) zu verwenden, um einen lauffähigen QR-Code-Detektor zu implementieren. Dessen Ein- sowie Ausgabe werden im Folgenden näher definiert.
Im Anschluss wird auf Details der Detektion eingegangen und erklärt, wie die Ausgabe aus der Eingabe gewonnen wird.
Grundsätzlich arbeitet das Programm in zwei Modi: dem \emph{Release}- und dem \emph{Live}-Modus.
Ersterer ist für die Evaluierung erstellt worden und erzeugt ein reines Konsolenprogramm, welches ohne weitere Umwege die Eingabe in die Ausgabe überführt.
Im \emph{Live}-Modus hingegen verwendet das Programm die Webcam des ausführenden Rechners, falls vorhanden als Eingabe. Es werden also, abhängig von deren Aufnahmeeigenschaften, kontinuierlich neue Eingaben und somit Ausgaben generiert. Dabei werden zusätzliche visuelle Ausgaben der durchgeführten Zwischenschritte erzeugt, welche im Unterkapitel \ref{s:detektion} näher erläutert werden.

\subsection{Eingabe}
\label{s:eingabe}

Als Eingabe für das im Rahmen des Praktikums erstellte Programm dient ein Bild in üblichem, d. h. von OpenCV lesbarem, Format. Als Beispiele seien hier \emph{JPG}, \emph{PNG} und \emph{BMP} genannt.
Dies darf nach Aufgabenstellung höchstens einen QR-Code enthalten.
Desweiteren schränken wir die Eingabe ein, indem wir höchstens drei \emph{Finder-Pattern} erkennen.
Im Falle des \emph{Live}-Modus generiert die verbundene Webcam die Eingabebilder.

\subsection{Ausgabe}
\label{s:ausgabe}

Die Ausgabe des Programms lässt sich erneut nach den beiden Modi aufteilen.
Im \emph{Release}-Modus wird genau ein Bild gemäß
TODO CHRISTIAN/FREDDY - AUFGABENSTELLUNG NENNEN
erstellt. Letztlich soll jedoch unterschieden werden, ob der QR-Code im Eingabebild erkannt werden konnte oder nicht. Im Falle eines Fehlers wird ein 1x1 Pixel großes, schwarzes Bild generiert. Bei erfolgreicher Detektion hingegen ein quadratisches Bild, deren Dimension exakt der des QR-Codes im Eingabebild entspricht.
Ein QR-Code mit 29x29 Modulen im Eingabebild erzeugt somit ein Ausgabebild der Größe 29x29 Pixeln, wobei die Farbe eines Pixels exakt dem Wert eines Moduls entspricht.
Das Bild wird verlustfrei im \emph{PNG}-Format gespeichert, um möglichen Datenverlust zu verhindern.
Im \emph{Live}-Modus hingegen wird keine Datei, sondern lediglich visuelle Ausgabe erzeugt. Das Ergebnis wird in einem Fenster angezeigt und kann direkt betrachtet werden. Auf weitere Details wird im folgenden Kapitel eingegangen.

\subsection{Detektion}
\label{s:detektion}

Der Begriff der Detektion lässt sich unmittelbar aus der Problemstellung herleiten.
Gefordert ist insbesondere nicht das Lesen des QR-Codes, sondern lediglich das Verorten und Normalisieren des QR-Codes, bzw. das Feststellen von dessen Abwesenheit im Bild. Die dafür notwendigen Schritte werden in den Unterkapiteln dieses Kapitels erläutert.

\subsubsection{Vorverarbeitung}
Die Vorverarbeitung spielt in der Bildverarbeitung meist eine große Rolle. Die Qualität von Echtweltdaten ist oftmals weit entfernt vom Óptimum, sodass die Anwendung eines Algorithmus auf diesen im Allgemeinen keine oder nur dürftige Ergebnisse liefert.
Dies trifft auch auf die gegenwärtige Problemstellung zu. Eingabebilder, insbesondere durch eine Webcam erzeugte, können mehrere Probleme aufweisen.
Geläufige Beispiele sind hierbei Rauschen, Verwaschungen und Unschärfe, welche durch den Sensor der Kamera, schlechte Lichtverhältnisse oder eine unruhige Kameraführung entstehen können.

%TODO Ausführen mit optischen Zwischenergebnissen
\begin{itemize}
	\item Graustufenbild
	\item Medianfilter
	\item global Thresholding (Otsu)
	\item Medianfilter
\end{itemize}

\subsubsection{Lokalisierung}

\subsubsection{Geometrische Normalisierung}

\subsubsection{Binarisierung}

\section{Evaluation}

\section{Fazit und Ausblick}
	
\end{document}


% Ref ohne BibTex???
% http://www.philippreiss.com/how-to-qr-code/
% https://de.wikipedia.org/wiki/QR-Code